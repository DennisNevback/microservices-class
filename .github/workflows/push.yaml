name: Deploy to Minikube
on:
  push:
    branches:
      - 05-setup-github-workflow 
jobs:
  build:
    runs-on: ubuntu-latest
    name: Deploy to minikube in Github Actions!
    steps:
    - uses: actions/checkout@v2
    - name: Start minikube
      uses: medyagh/setup-minikube@master
    - name: Try the cluster
      run: kubectl get pods -A
    - name: Setup Docker environment
      run: |
        export SHELL=/bin/bash
        eval $(minikube -p minikube docker-env)
    - name: Print current app version
      run: |
        echo "current_version=$(grep '# version' version.md | cut -d ' ' -f3)" >> $GITHUB_ENV
        echo "Current version: ${{ env.current_version }}"
    - name: Generate Modified Deployment YAML
      run: |
        sed -e "s/microservice1:1.0.0/microservice1:${{ env.current_version }}/g" deployment-service1.yaml > modified-deployment-service1.yaml
        sed -e "s/microservice2:1.0.0/microservice1:${{ env.current_version }}/g" deployment-service2.yaml > modified-deployment-service2.yaml
    - name: Build microservice1 image
      run: docker build -f ./service1/Dockerfile -t microservice1:${{ env.current_version }} ./service1
    - name: Build microservice2 image
      run: docker build -f ./service2/Dockerfile -t microservice2:${{ env.current_version }} ./service2
    - name: Print docker images
      run: docker images 
    - name: Deploy to minikube
      run: |
        kubectl apply -f modified-deployment-service1.yaml
        kubectl apply -f modified-deployment-service2.yaml
        kubectl apply -f service-service1.yaml
        kubectl apply -f service-service2.yaml
    - name: List deployments
      run: kubectl get deploy
    - name: List services
      run: kubectl get service
    - name: List pods
      run: kubectl get pods
    - name: Wait for pods to be ready
      run: |
        # Define the namespace selector for your pods
        NAMESPACE=default
        
        # Set a timeout limit (adjust as needed)
        TIMEOUT_SECONDS=600  # 10 minutes
        
        # Start a timer to track elapsed time
        start_time=$(date +%s)
        
        # Loop until all pods are in the "Running" state or until timeout is reached
        while true; do
          # Get the list of pods in the namespace with the given label selector
          pod_status=$(kubectl get pods -n "$NAMESPACE" -o jsonpath='{range .items[*]}{.status.phase}{"\n"}{end}')
          
          # Count the number of pods in the "Running" state
          running_pods=$(echo "$pod_status" | grep -c "Running")
          
          # Count the total number of pods
          total_pods=$(echo "$pod_status" | wc -l)
          
          echo "Running pods: $running_pods / $total_pods"
          
          # Check if all pods are in the "Running" state
          if [ "$running_pods" -eq "$total_pods" ]; then
            echo "All pods are running and ready."
            break
          fi
          
          # Check if the timeout has been reached
          current_time=$(date +%s)
          elapsed_time=$((current_time - start_time))
          if [ "$elapsed_time" -ge "$TIMEOUT_SECONDS" ]; then
            echo "Timeout reached. Not all pods are running."
            exit 1
          fi
          
          # Sleep for a few seconds before checking again (adjust as needed)
          sleep 1
        done
      timeout-minutes: 15  # Adjust the timeout for the entire step as needed


    - name: Test service URLs
      run: |
        minikube service list
        minikube service service2-service --url
        echo "------------------opening the service------------------"
        curl $(minikube service service2-service --url)        
